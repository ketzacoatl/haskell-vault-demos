{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE RecordWildCards #-}

module Lib
  ( runDemo
  ) where

import Control.Monad.IO.Class (liftIO)
import Data.Aeson
import Data.Foldable (forM_)

import Data.Text
  ( pack
  , Text(..)
  )

import Faker
import Faker.Combinators (listOf)
import Faker.Name
import Faker.Movie.BackToTheFuture
import Faker.Internet (freeEmail)

import Network.VaultTool
  ( connectToVault
  , vaultHealth
  , vaultListRecursive
  , vaultWrite
  , VaultAddress (..)
  , VaultAuthToken (..)
  , VaultConnection (..)
  , VaultHealth (..)
  , VaultMountedPath (..)
  , VaultSearchPath (..)
  , VaultSecretPath (..)
  )

import Say (say, sayShow)

vaultURL :: VaultAddress
vaultURL = VaultAddress "http://127.0.0.1:8200"

vaultToken :: VaultAuthToken
vaultToken = VaultAuthToken "xyzrootoken" -- TODO: pull this from a envvar

kvSecretMount :: VaultMountedPath
kvSecretMount = VaultMountedPath "secret"

mySecretKey :: VaultSearchPath
mySecretKey = VaultSearchPath "my-secret"

data Contact = Contact
       { name :: Text
       , email :: Text
       , message :: Text
       } deriving Show

instance ToJSON Contact where
    toJSON (Contact name email message) = object
        [ "name" .= name
        , "email" .= email
        , "message" .= message
        ]

data VaultContact = VaultContact
       { vaultData :: Contact
       } deriving Show
       
instance ToJSON VaultContact where
    toJSON (VaultContact vaultData) = object [ "data" .= vaultData ]

autoGeneratedContact :: Fake Contact
autoGeneratedContact = do
  contactName <- Faker.Name.name
  contactText <- Faker.Movie.BackToTheFuture.quote
  contactEmail <- freeEmail
  pure $ Contact{..}

autoGenerateListOfContacts :: IO [Contact]
autoGenerateListOfContacts = do
  clist <- generate $ listOf 1000 autoGeneratedContact
  return clist

writeContactToVault :: VaultConnection -> Text -> Contact -> IO()
writeContactToVault vc id msg = vaultWrite vc (VaultSecretPath (kvSecretMount, VaultSearchPath ("contacts/"<>id))) (toJSON (VaultContact {vaultData = msg}))

printContact :: a -> IO ()
printContact c = sayShow c

runDemo :: IO ()
runDemo = do
  say "check vault status.."
  (status :: VaultHealth) <- vaultHealth vaultURL
  say $ pack $ show status
  --
  say "connecting to vault (authenticated)"
  vaultConnection <- connectToVault vaultURL vaultToken
  --
  say "writing some contacts to vault"
  --contactsList <- liftIO $ autoGenerateListOfContacts
  contactsList <- generate $ listOf 1000 autoGeneratedContact
  forM_ printContact contactsList
  --forM_ printContact contactsList
  --writeContactToVault vaultConnection "some-uuid1" $ (head contactsList)
  --writeContactToVault vaultConnection "some-uuid2" msgTwo
  --
