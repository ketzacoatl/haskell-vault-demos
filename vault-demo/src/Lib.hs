{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE RecordWildCards #-}

module Lib
  ( runDemo
  ) where

import Control.Monad.IO.Class (liftIO)
import Data.Aeson
import Data.Foldable (forM_)
import Data.Maybe    (fromJust)
import Data.UUID     (toText, UUID (..))
import Data.UUID.V4  (nextRandom)

import Data.Text
  ( pack
  , Text(..)
  )

import Faker
import Faker.Combinators (listOf)
import Faker.Name
import Faker.Movie.BackToTheFuture
import Faker.Internet (freeEmail)

import Network.VaultTool
  ( connectToVault
  , vaultHealth
  , vaultList
  , vaultListRecursive
  , vaultWrite
  , VaultAddress (..)
  , VaultAuthToken (..)
  , VaultConnection (..)
  , VaultHealth (..)
  , VaultMountedPath (..)
  , VaultSearchPath (..)
  , VaultSecretPath (..)
  )

import Say (say, sayShow)

vaultURL :: VaultAddress
vaultURL = VaultAddress "http://127.0.0.1:8200"

vaultToken :: VaultAuthToken
vaultToken = VaultAuthToken "xyzrootoken" -- TODO: pull this from a envvar

kvSecretMount :: VaultMountedPath
kvSecretMount = VaultMountedPath "secret"

mySecretKey :: VaultSearchPath
mySecretKey = VaultSearchPath "my-secret"

data Contact = Contact
       { name :: Text
       , email :: Text
       , message :: Text
       } deriving Show

instance ToJSON Contact where
    toJSON (Contact name email message) = object
        [ "name" .= name
        , "email" .= email
        , "message" .= message
        ]

data VaultContact = VaultContact
       { vaultData :: Contact
       } deriving Show
       
instance ToJSON VaultContact where
    toJSON (VaultContact vaultData) = object [ "data" .= vaultData ]

autoGeneratedContact :: Fake Contact
autoGeneratedContact = do
  name <- Faker.Name.name
  message <- Faker.Movie.BackToTheFuture.quote
  email <- freeEmail
  pure $ Contact{..}

autoGenerateListOfContacts :: IO [Contact]
autoGenerateListOfContacts = do
  clist <- generate $ listOf 1000 autoGeneratedContact
  return clist

writeContactToVault :: VaultConnection -> Contact -> IO()
writeContactToVault vc c = do
  contactId <- nextRandom
  let contactKey = "contacts/" <> toText contactId
      vaultKeyPath = VaultSearchPath contactKey
      contact = toJSON (VaultContact {vaultData = c})
  vaultWrite vc (VaultSecretPath (kvSecretMount, vaultKeyPath)) contact

printContact :: Show a => a -> IO ()
printContact c = sayShow c

runDemo :: IO ()
runDemo = do
  say "Check vault status.."
  (status :: VaultHealth) <- vaultHealth vaultURL
  say $ pack $ show status

  say "Connecting to vault (authenticated)"
  vaultConnection <- connectToVault vaultURL vaultToken

  say "Generating some contacts with fake data, this will take time.."
  contactsList <- generate $ listOf 100 autoGeneratedContact
  mapM_ printContact contactsList

  say "Writing contacts to Vault.."
  mapM_ (writeContactToVault vaultConnection) contactsList
  say "Retrieving contacts from Vault and printing.."
  keys <- vaultList vaultConnection (VaultSecretPath (kvSecretMount, (VaultSearchPath "contacts/")))
  say "Printing contacts retrieved from Vault.."
  mapM_ sayShow keys